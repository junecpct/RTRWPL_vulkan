/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#include "raycommon.glsl"
#include "wavefront.glsl"

//#extension GL_EXT_debug_printf : enable


layout(set = 1, binding = eImplicit, scalar) buffer allSpheres_
{
  Sphere allSpheres[];
};


struct Ray
{
  vec3 origin;
  vec3 direction;
};



// Ray-Sphere intersection

float hitSphere(const Sphere s, const Ray r)
{
  vec3  oc           = r.origin - s.center;
  float a            = dot(r.direction, r.direction);
  float half_b            = dot(oc, r.direction);
  float c            = dot(oc, oc) - s.radius * s.radius;
  float discriminant = half_b * half_b - a * c;

  float tmin = gl_RayTminEXT;
  float tmax = gl_RayTmaxEXT;
  if (discriminant < 0.0) {
        return -1.0; // No intersection
    }

    float sqrtd = sqrt(discriminant);

    float root = (-half_b - sqrtd) / a;
    if (root < tmin || tmax < root) {
        root = (-half_b + sqrtd) / a;
        if (root < tmin || tmax < root) {
            return -1.0; // No valid intersection
        }
    }

    return root; // Intersection at distance 'root'
}

void main()
{
  Ray ray;
  ray.origin    = gl_ObjectRayOriginEXT;
  ray.direction = gl_ObjectRayDirectionEXT;

  //debugPrintfEXT("direction: %f, %f, %f\n", ray.direction.x, ray.direction.y, ray.direction.z);

  // Sphere data
  Sphere sphere = allSpheres[gl_PrimitiveID];

  float tHit    = -1;
  int   hitKind = KIND_SPHERE;

  // Sphere intersection
  tHit = hitSphere(sphere, ray);

  // Report hit point
  if(tHit > 0)
    reportIntersectionEXT(tHit, hitKind);
}
